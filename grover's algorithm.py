# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gypjK0Ut1dOjVnmYcaObVJUP64Jg355g
"""

# grover_demo.py

from qiskit import QuantumCircuit, Aer, execute
import numpy as np


def grover_oracle(n_qubits: int, target: str) -> QuantumCircuit:
    """
    Oracle that flips the phase of the target basis state |target>.
    target is a bitstring like "101" of length n_qubits.
    """
    oracle = QuantumCircuit(n_qubits)

    # Step 1: Flip qubits where target has '0' so that target maps to |111...1>
    for i, bit in enumerate(target):
        if bit == '0':
            oracle.x(i)

    # Step 2: Multi-controlled Z on |111...1>
    oracle.h(n_qubits - 1)
    oracle.mcx(list(range(n_qubits - 1)), n_qubits - 1)  # multi-controlled X
    oracle.h(n_qubits - 1)

    # Step 3: Uncompute the X gates
    for i, bit in enumerate(target):
        if bit == '0':
            oracle.x(i)

    return oracle


def diffuser(n_qubits: int) -> QuantumCircuit:
    """
    Diffuser (inversion about the mean) used in Grover's algorithm.
    """
    diff = QuantumCircuit(n_qubits)

    # Put into |+> basis
    diff.h(range(n_qubits))
    diff.x(range(n_qubits))

    # Multi-controlled Z on |000...0> (after X this corresponds to |111...1>)
    diff.h(n_qubits - 1)
    diff.mcx(list(range(n_qubits - 1)), n_qubits - 1)
    diff.h(n_qubits - 1)

    # Undo the X and H
    diff.x(range(n_qubits))
    diff.h(range(n_qubits))

    return diff


def grover_search(n_qubits: int, target: str, shots: int = 1024):
    """
    Build and run Grover's algorithm circuit for a given target bitstring.
    """
    if len(target) != n_qubits:
        raise ValueError("target bitstring length must equal n_qubits")

    # Quantum circuit with n_qubits and n_qubits classical bits
    qc = QuantumCircuit(n_qubits, n_qubits)

    # Step 1: Start with equal superposition over all states
    qc.h(range(n_qubits))

    # Build oracle and diffuser
    oracle = grover_oracle(n_qubits, target)
    diff = diffuser(n_qubits)

    # Number of optimal iterations ~ pi/4 * sqrt(N)
    N = 2 ** n_qubits
    iterations = int(np.floor(np.pi / 4 * np.sqrt(N)))
    print(f"Using {iterations} Grover iterations for N = {N}")

    # Step 2: Apply Grover iterations
    for _ in range(iterations):
        qc.compose(oracle, inplace=True)
        qc.compose(diff, inplace=True)

    # Step 3: Measure
    qc.measure(range(n_qubits), range(n_qubits))

    # Run on simulator
    backend = Aer.get_backend("qasm_simulator")
    job = execute(qc, backend=backend, shots=shots)
    result = job.result()
    counts = result.get_counts()

    print("Measurement counts:")
    for state, count in sorted(counts.items(), key=lambda x: x[1], reverse=True):
        print(f"  {state}: {count}")

    return qc, counts


if __name__ == "__main__":
    # Example: 3-qubit Grover search for target |101>
    n_qubits = 3
    target_state = "101"

    print(f"Running Grover's algorithm for target state |{target_state}>")
    circuit, counts = grover_search(n_qubits, target_state)

    # If you want to see the circuit in text form:
    print("\nFinal circuit:")
    print(circuit)